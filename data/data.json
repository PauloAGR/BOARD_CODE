{
    "settings": [
        {
            "NETWORK": {
                "MQTT": {
                    "BROKER_ADRESS": "IP_ADDRESS",
                    "PORT": "PORT_NUMBER",
                    "CLIENT": "ID_CLIENT",
                    "PASS": "PASS_CLIENT",
                    "TOPICS":["DEVICE/ID/"]
                },
                "WIFI_STA": {
                    "SSID": "NAME",
                    "PASSWD": "PASSWD",
                    "STATIC_IP": "BOOL",
                    "STATIC_IP_ADDRESS": "STATIC_IP_ADDRESS",
                    "DNS": [
                        "DNS_IP_ADDRESS_1",
                        "DNS_IP_ADDRESS_2"
                    ],
                    "GATEWAY": "IP_GATEWAY"
                },
                "WIFI_AP": {
                    "SSID": "NAME",
                    "PASS": "PASS",
                    "STATIC_IP": "BOOL",
                    "STATIC_IP_ADDRESS": "STATIC_IP_ADDRESS",
                    "GATEWAY": "IP_GATEWAY"
                }
            }
        },
        {
            "DEVICE": {
                "ID": "ID",
                "VERSION": "VERSION"
            }
        },
        {
            "IO_PINS": [
                {
                    "NUMBER": "GPIO_NUMBER",
                    "STATE": "HIGH/LOW"
                }
            ]
        }
    ],
    "backup":"/*
    * Copyright © Paulo Andrés Guerrero Ramírez
    *
    */
   
   #include <Arduino.h>
   #include <WiFi.h>
   #include "ESPAsyncWebServer.h"
   #include <PubSubClient.h>
   #include "SPIFFS.h"
   #include <ArduinoJson.h>
   #include "time.h"
   
   #define LIGHT_SENSOR_PIN 36 // ESP32 pin GIOP36 (ADC0)
   
   const char *WIFI_NAME = "KNIGHTS_FORTRESS";
   const char *WIFI_PASS = "covenant";
   
   AsyncWebServer server(80);
   AsyncWebSocket webSocket("/ws");
   
   // TODO: Finish MQTT configurations --- Check MQTT conect config... almost done MQTT
   const char *MQTT_BROKER_ADRESS = "192.168.1.96";
   const uint16_t MQTT_PORT = 1883;
   const char *MQTT_CLIENT_ID = "grupo_1";
   const char *MQTT_CLIENT_USER = "grupo_1";
   const char *MQTT_CLIENT_PASS = "grupo_1";
   
   WiFiClient espHost;
   PubSubClient espMQTTClient(espHost);
   String subsTopic = "esp32/id/grupo1";
   // String content = "";
   String payload;
   
   static int sensorVal = 0;
   
   const char *ntpServer = "co.pool.ntp.org";
   // const long gmtOffset_sec = 0;
   // const int daylightOffset_sec = 0;
   // struct tm timeinfo;
   
   void notFound(AsyncWebServerRequest *request)
   {
     request->send(404, "text/plain", "Not found");
   }
   
   void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len)
   {
     if (type == WS_EVT_CONNECT)
     {
       // client connected
       Serial.println("Client connected....");
       Serial.printf("ws[%s][%u] connect\n", server->url(), client->id());
       client->ping();
     }
     else if (type == WS_EVT_DISCONNECT)
     {
       // client disconnected
       Serial.printf("ws[%s][%u] disconnect: %u\n", server->url(), client->id());
     }
     else if (type == WS_EVT_ERROR)
     {
       // error was received from the other end
       Serial.printf("ws[%s][%u] error(%u): %s\n", server->url(), client->id(), *((uint16_t *)arg), (char *)data);
     }
     else if (type == WS_EVT_PONG)
     {
       // pong message was received (in response to a ping request maybe)
       Serial.printf("ws[%s][%u] pong[%u]: %s\n", server->url(), client->id(), len, (len) ? (char *)data : "");
     }
     else if (type == WS_EVT_DATA)
     {
       // do nothing as client is not sending message to server
       Serial.printf("ws[%s][%u] data received\n", server->url(), client->id());
     }
   }
   
   void fileSystemCheck()
   {
     if (!SPIFFS.begin())
     {
       Serial.println("An Error has occurred while mounting SPIFFS");
       return;
     }
   }
   
   void enableWiFi()
   {
     WiFi.mode(WIFI_STA);
     WiFi.begin(WIFI_NAME, WIFI_PASS);
     if (WiFi.waitForConnectResult() != WL_CONNECTED)
     {
       Serial.printf("WiFi Failed!\n");
       return;
     }
     Serial.print("IP Address: ");
     Serial.println(WiFi.localIP());
   }
   
   void webSocketInit()
   {
     webSocket.onEvent(onEvent);
     server.addHandler(&webSocket);
   }
   
   void webServerInit()
   {
     // Route for root index.html
     server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
               { 
                 AsyncWebServerResponse* response = request->beginResponse(SPIFFS, "/index.html.gz", "text/html");
                   response->addHeader("Content-Encoding", "gzip");
                   response->addHeader("Cache-Control", "max-age=86400"); // 1 día
                   request->send(response); });
   
     // Route for root index.css
     // server.on("/assets/index-2613cd82.css", HTTP_GET, [](AsyncWebServerRequest *request)
     //           {
     //             AsyncWebServerResponse* response = request->beginResponse(SPIFFS, "/assets/index-2613cd82.css.gz", "text/css");
     //             response->addHeader("Content-Encoding", "gzip");
     //             response->addHeader("Cache-Control", "max-age=86400"); // 1 día
     //             request->send(response); });
   
     // Route for root index.js
     server.on("/assets/index-e3e6aa6b.js", HTTP_GET, [](AsyncWebServerRequest *request)
               {
                 AsyncWebServerResponse* response = request->beginResponse(SPIFFS, "/assets/index-e3e6aa6b.js.gz", "application/javascript");
                 response->addHeader("Content-Encoding","gzip");
                 response->addHeader("Cache-Control","max-age=86400"); // 1 día
                 request->send(response); });
   
     server.onNotFound(notFound);
   
     // Start the server
     server.begin();
   }
   
   void suscribeMqtt()
   {
     espMQTTClient.subscribe("esp32/#");
   }
   
   // void onMqttReceived(char *topic, byte *payload, unsigned int length)
   // {
   //   Serial.print("Received on ");
   //   Serial.print(topic);
   //   Serial.println(": ");
   
   //   content = "";
   //   for (size_t i = 0; i < length; i++)
   //   {
   //     content.concat((char)payload[i]);
   //   }
   //   // Serial.print(content);
   //   // Serial.println();
   //   StaticJsonDocument<300> doc;
   //   DeserializationError error = deserializeJson(doc, content);
   //   if (error)
   //     return;
   //   serializeJsonPretty(doc, Serial);
   //   String json = "";
   //   serializeJson(doc, json);
   //   //webSocket.printfAll((json).c_str());
   //   //  unsigned long data = doc["value"];
   //   //  Serial.print("Millis:");
   // }
   
   void enableMQTT()
   {
     espMQTTClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);
     suscribeMqtt();
     // espMQTTClient.setCallback(onMqttReceived);
   }
   
   void connectMqtt()
   {
     while (!espMQTTClient.connected())
     {
       Serial.print("Starting MQTT connection...");
       if (espMQTTClient.connect(MQTT_CLIENT_ID, MQTT_CLIENT_USER, MQTT_CLIENT_PASS))
       {
         suscribeMqtt();
       }
       else
       {
         Serial.print("Failed MQTT connection, rc=");
         Serial.print(espMQTTClient.state());
       }
     }
   }
   
   void publisMqtt(DynamicJsonDocument doc)
   {
     payload = "";
     // DynamicJsonDocument jsonDoc (2048);
     // // jsonDoc["device_id"] = "parzival";
     // // jsonDoc["type"] = "light";
     // // jsonDoc["value"] = data;
     serializeJson(doc, payload);
     espMQTTClient.publish((char *)subsTopic.c_str(), (char *)payload.c_str());
   }
   
   void handleMqtt()
   {
     if (!espMQTTClient.connected())
     {
       connectMqtt();
     }
     espMQTTClient.loop();
   }
   
   void readLDR()
   {
     // reads the input on analog pin (value between 0 and 4095)
     int analogValue = analogRead(LIGHT_SENSOR_PIN);
     if (!analogValue != sensorVal)
     {
       struct tm timeinfo;
       if (!getLocalTime(&timeinfo))
       {
         Serial.println("Failed to obtain time");
         return;
       }
       char time[18];
       strftime(time, 18, "%y/%m/%d %H:%M:%S", &timeinfo);
       DynamicJsonDocument doc(255);
       sensorVal = analogValue;
       doc["time"] = time;
       doc["sensor"] = "light";
       doc["value"] = sensorVal;
       serializeJsonPretty(doc, Serial);
       publisMqtt(doc);
       String output;
       serializeJson(doc, output);
       webSocket.printfAll(output.c_str());
     }
   }
   
   // String converToJSON(int c_keys, char *keys, char *values)
   // {
   //   const size_t CAPACITY = JSON_OBJECT_SIZE(c_keys);
   //   DynamicJsonDocument doc(CAPACITY);
   // }
   
   // void splitString(char *buf, JsonDocument doc)
   // {
   //   const char *p = buf, *q;
   //   // int num_tokens = 1;
   
   //   while ((q = strchr(p, '#')) != NULL)
   //   {
   //     char destino[strlen(q) + 1];
   //     strncpy(destino, p, strlen(p) - strlen(q));
   //     printf("destino: %s\n", destino);
   //     p = q + 1;
   //   }
   // }
   
   // void printLocalTime()
   // {
   //   struct tm timeinfo;
   //   if (!getLocalTime(&timeinfo))
   //   {
   //     Serial.println("Failed to obtain time");
   //     return;
   //   }
   //   Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
   //   Serial.print("Day of week: ");
   //   Serial.println(&timeinfo, "%A");
   //   Serial.print("Month: ");
   //   Serial.println(&timeinfo, "%B");
   //   Serial.print("Day of Month: ");
   //   Serial.println(&timeinfo, "%d");
   //   Serial.print("Year: ");
   //   Serial.println(&timeinfo, "%Y");
   //   Serial.print("Hour: ");
   //   Serial.println(&timeinfo, "%H");
   //   Serial.print("Hour (12 hour format): ");
   //   Serial.println(&timeinfo, "%I");
   //   Serial.print("Minute: ");
   //   Serial.println(&timeinfo, "%M");
   //   Serial.print("Second: ");
   //   Serial.println(&timeinfo, "%S");
   
   //   Serial.println("Time variables");
   //   char timeHour[3];
   //   strftime(timeHour, 3, "%H", &timeinfo);
   //   Serial.println(timeHour);
   //   char timeWeekDay[10];
   //   strftime(timeWeekDay, 10, "%A", &timeinfo);
   //   Serial.println(timeWeekDay);
   //   Serial.println();
   // }
   void setTime()
   {
     configTime(0, 0, ntpServer);
     setenv("TZ", "EST5EDT,M3.2.0,M11.1.0", 1); //  Now adjust the TZ.  Clock settings are adjusted to show the new local time
     tzset();
     // printLocalTime();
   }
   void setup()
   {
     // configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
     Serial.begin(115200);
     Serial.println("Starting system...");
   
     // Begin LittleFS for ESP8266 or SPIFFS for ESP32
     fileSystemCheck();
   
     // Connect to WIFI
     enableWiFi();
   
     // attach AsyncWebSocket
     webSocketInit();
   
     // Serve files for Web Dashboard
     webServerInit();
   
     // Stablish conection to MQTT server
     enableMQTT();
   
     setTime();
   }
   
   void loop()
   {
   
     // Read the LDR values continously
     readLDR();
   
     // MQTT
     handleMqtt();
     // printLocalTime();
     delay(5000);
   }
   "
}